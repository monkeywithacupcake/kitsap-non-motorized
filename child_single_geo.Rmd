

# {{current_geo}}

```{r} 
#library(broom)

this_geo <- st_as_sf(loop_df) %>% filter(tomatch == "{{current_geo}}") 
this_roads <- st_intersection(road_df, st_buffer(this_geo,0))
this_sw_sh <- st_intersection(nc_sw_sh, st_buffer(this_geo,0))

# need to handle the case where this_sw_sh or this_roads has 0 rows
has_roads <- nrow(this_roads) != 0
has_sw_sh <- nrow(this_sw_sh) != 0
has_both <- has_roads & has_sw_sh
# do not evaluate most of this child if does not
```

```{r, results = 'asis', eval=!has_roads}
cat("This area does not have either known roads.")
```

```{r, results = 'asis', eval=!has_sw_sh}
cat("This area does not have known sidewalks or shoulders.")
```

```{r, eval=has_sw_sh & !has_roads}
this_centerline_miles <- 0 # this_centerline_miles is CENTERLINE MILES TOTAL
# this_sw/sh_miles is RIGHT LEFT MILES with SW or SH TOTAL
this_sw_sh_miles <- format(round(as.numeric(sum(st_length(this_sw_sh))/5280), 1), 
                           digits = 1, nsmall=1, big.mark=",")
# this_comb_miles is RIGHT LEFT MILES where we could match SW/SH to a road segment
this_comb_miles <- 0
```
```{r, eval=!has_sw_sh & has_roads}
# this_centerline_miles is CENTERLINE MILES TOTAL
this_centerline_miles <- format(round(as.numeric(sum(st_length(this_roads))/5280), 1), 
                           digits = 1, nsmall=1, big.mark=",")
# this_sw/sh_miles is RIGHT LEFT MILES with SW or SH TOTAL
this_sw_sh_miles <- 0
# this_sw/sh_miles is RIGHT LEFT MILES where we could match SW/SH to a road segment
this_comb_miles <- 0
```

```{r, eval=has_both}
# identified a mislabeled RD_LOG_ID in the sidewalk data for Madrone (as Main)
x <- st_as_sf(this_sw_sh) %>% mutate(LENGTH = as.integer(LENGTH)) %>% filter(RD_LOG_ID == 49435 & LENGTH > 1000)
x$RD_LOG_ID <- 43809
# x will have 0 rows if we are not dealing with Manchester

# comb will have repeating segments when there are sh/sw on both sides
this_comb <- st_intersection(select(this_roads, RD_LOG_ID_R = RD_LOG_ID, 
                                     SEGMENT_ID_R = SEGMENT_ID,
                                     FULL_NAME_R = FULL_NAME, 
                                     LENGTH_R = LENGTH,
                                     road_class, RUCODE), 
                             st_buffer(bind_rows(this_sw_sh, x), 50, endCapStyle="FLAT")) %>% 
  filter(RD_LOG_ID == RD_LOG_ID_R) %>%
  distinct(RD_LOG_ID_R, SEGMENT_ID_R, RD_LOG_ID, SEGMENT_ID, SIDE_OF_RO, .keep_all = TRUE) %>%
  mutate(distance = st_length(.))

# this_centerline_miles is CENTERLINE MILES TOTAL
this_centerline_miles <- format(round(as.numeric(sum(st_length(this_roads))/5280), 1), 
                           digits = 1, nsmall=1, big.mark=",")
# this_sw/sh_miles is RIGHT LEFT MILES with SW or SH TOTAL
this_sw_sh_miles <- format(round(as.numeric(sum(st_length(this_sw_sh))/5280), 1), 
                           digits = 1, nsmall=1, big.mark=",")
# this_sw/sh_miles is RIGHT LEFT MILES where we could match SW/SH to a road segment
this_comb_miles <- format(round(as.numeric(sum(st_length(this_comb))/5280), 1), 
                           digits = 1, nsmall=1, big.mark=",")

# ggplot() +
#   geom_sf(data = this_geo, aes(fill = 1), alpha = 0.2, lwd = 0, show.legend = FALSE) + 
#   geom_sf(data = st_buffer(bind_rows(this_sw_sh, x), 50, endCapStyle="FLAT"),
#           fill = "#4E22EE", alpha = 0.5) +
#   geom_sf(data = this_roads, aes(color = 1), color = "#999999", alpha = 0.5) + 
#   geom_sf(data = this_test2, color = "black") +
#   geom_sf(data = this_sw_sh, aes(color = as.factor(RD_LOG_ID)), lwd = 0) 


          

```

Within this area, there are `r this_centerline_miles` centerline road miles; `r this_sw_sh_miles` miles of recorded sidewalk or shoulder (either side of road); and `r this_comb_miles` miles where we could match the recorded sidewalk or shoulder to a road segment (either side of road).

```{r, eval=has_both}

road_sum <- this_roads %>%
  mutate(distance = st_length(.)) %>%  
  st_set_geometry(., NULL) %>% 
  group_by(road_class) %>%
  summarise(t_miles = sum(distance)/5280,
            miles = format(round(as.numeric(sum(distance)/5280), 1), 
                           digits = 1, nsmall=1, big.mark=","),
            .groups = "drop")
df <- select(road_sum, -t_miles)
colnames(df) <- c("Road Class", "Miles")
knitr::kable(df)
```

And we still need to get this into segment scores, but here are the miles with sidewalks or shoulders.

```{r, eval=has_both}
df <- this_comb %>% st_set_geometry(., NULL) %>% 
  group_by(road_class, SIDE_OF_RO, TYPE) %>%
  summarize(s_miles = sum(distance)/5280,
            miles = format(round(as.numeric(sum(distance)/5280), 1), 
                           digits = 1, nsmall=1, big.mark=","),
            .groups = "drop")
knitr::kable(select(df,-s_miles))
```

```{r, eval=has_both}
p1 <- kitsap +
  geom_sf(data = this_geo, aes(fill = 1), alpha = 0.5, show.legend = FALSE) +
  geom_sf(data = this_roads, aes(color = 1), color = "#999999", alpha = 0.5) +
  geom_sf(data = this_sw_sh, aes(color = as.factor(TYPE)), show.legend = "line") + 
  sw_sh_col +
  theme_void() +
  labs(title = paste("Map for","{{current_geo}}"),
       caption = "Data source: Kitsap GIS - data in development",
       color = "Pedestrian Facilities")

     


r <- ggplot() +
  geom_sf(data = this_geo, aes(fill = 1), alpha = 0.4, lwd = 0, show.legend = FALSE) +
  geom_sf(data = this_roads, aes(color = 1), color = "#999999", alpha = 0.5) + 
  #geom_sf(data = filter(this_sw_sh, SIDE_OF_RO == "RIGHT"), aes(linetype = as.factor(RD_LOG_ID)), color = "black") +
  geom_sf(data = filter(this_sw_sh, SIDE_OF_RO == "RIGHT"), aes(color = as.factor(TYPE))) +
  sw_sh_col +
  labs(title = "Right",
       color = "Pedestrian Facilities") +
  theme_void()

l <- ggplot() +
  geom_sf(data = this_geo, aes(fill = 1), alpha = 0.4, lwd = 0, show.legend = FALSE) +
  geom_sf(data = this_roads, aes(color = 1), color = "#999999", alpha = 0.5) + 
  #geom_sf(data = filter(this_sw_sh, SIDE_OF_RO == "LEFT"), aes(linetype = as.factor(RD_LOG_ID)), color = "black") +
  geom_sf(data = filter(this_sw_sh, SIDE_OF_RO == "LEFT"), aes(color = as.factor(TYPE))) +
  sw_sh_col +
  labs(title = "Left",
       color = "Pedestrian Facilities") +
  theme_void()



p2 <- ggplot() +
  geom_sf(data = this_geo, aes(fill = 1), alpha = 0.5, show.legend = FALSE) +
  geom_sf(data = this_roads, aes(color = 1), color = "#999999", alpha = 0.5) + 
  geom_sf(data = this_sw_sh, aes(color = as.factor(TYPE)), show.legend = FALSE) +
  theme_void()

library(patchwork)

(p1 + #l + r + #p2 +
  plot_layout(guides = 'collect') +
  labs(title = paste("Map for","{{current_geo}}"),
       caption = "Data source: Kitsap GIS - data in development",
       color = "Pedestrian Facilities") & 
    theme(legend.position = "bottom") ) +
  (l + theme(legend.position = "none") ) +
  (r + theme(legend.position = "none") )

detach("package:patchwork", unload=TRUE)

```

```{r eval=has_both}
this_comb_stand <- this_comb %>% 
  st_set_geometry(., NULL) %>% 
  mutate(setting = ifelse(RUCODE == 1, "Rural", 
                          ifelse(RUCODE == 2, "Urban", "Unknown")),
         ped_type = sub("\\:.*", "", TYPE),
         nn = paste(sub("paved ","",tolower(ped_type)), tolower(SIDE_OF_RO),sep ="_")) %>%
  pivot_wider(id_cols = c(-RD_LOG_ID:-TYPE,-ped_type), 
              names_from = nn, 
              values_from = WIDTH,
              values_fn = mean) %>%
  left_join(road_standards) %>%
  rowwise() %>% # now make sure that have all the columns
  mutate(sidewalk_left = ifelse("sidewalk_left" %in% names(.), sidewalk_left, NA),
         sidewalk_right = ifelse("sidewalk_right" %in% names(.), sidewalk_right, NA),
         shoulder_left = ifelse("shoulder_left" %in% names(.), shoulder_left, NA),
         shoulder_right = ifelse("shoulder_right" %in% names(.), shoulder_right, NA)
         )

this_comb_score <- this_comb_stand %>%
  mutate(score_left = getSideScore(standard_sidewalk, standard_shoulder, 
                                   sidewalk_left, shoulder_left),
         score_right = getSideScore(standard_sidewalk, standard_shoulder, 
                                   sidewalk_right, shoulder_right),
         score = score_left + score_right)
this_comb_score2 <- st_set_geometry(this_roads, NULL) %>% 
  select(RD_LOG_ID_R = RD_LOG_ID, SEGMENT_ID_R = SEGMENT_ID,
         FULL_NAME_R = FULL_NAME, road_class, RUCODE, LENGTH) %>%
  mutate(setting = ifelse(RUCODE == 1, "Rural", 
                          ifelse(RUCODE == 2, "Urban", "Unknown"))) %>%
  left_join(this_comb_score) %>%
  mutate(the_score = ifelse(is.na(score), 0, score),
         the_length = ifelse(is.na(distance), LENGTH, distance),
         w_score = the_score*the_length)

this_comb_total_score <- sum(this_comb_score2$w_score)/sum(this_comb_score2$the_length)
```

The overall score for pedestrian facilities in {{current_geo}} is `r nice_comma(this_comb_total_score)`, `r getScoreInterpretation(this_comb_total_score)`.

```{r}
# next step
# take the comb data, get the distance for each segment
# combine that with this roads
# where no sw sh = 0
# determine if meets criteria

```